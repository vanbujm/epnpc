### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


enum Aptitude {
  COG
  INT
  REF
  SAV
  SOM
  WIL
}

scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

type Ego {
  cog: Int!
  id: ID!
  int: Int!
  name: String!
  ref: Int!
  sav: Int!
  skills(after: String, before: String, first: Int, last: Int, skip: Int): [Skill!]!
  som: Int!
  wil: Int!
}

input EgoCreateInput {
  cog: Int!
  id: ID
  int: Int!
  name: String!
  ref: Int!
  sav: Int!
  skills: SkillCreateManyWithoutSkillsInput
  som: Int!
  wil: Int!
}

input EgoCreateOneWithoutEgoInput {
  connect: EgoWhereUniqueInput
  create: EgoCreateWithoutSkillsInput
}

input EgoCreateWithoutSkillsInput {
  cog: Int!
  id: ID
  int: Int!
  name: String!
  ref: Int!
  sav: Int!
  som: Int!
  wil: Int!
}

input EgoUpdateInput {
  cog: Int
  id: ID
  int: Int
  name: String
  ref: Int
  sav: Int
  skills: SkillUpdateManyWithoutEgoInput
  som: Int
  wil: Int
}

input EgoUpdateOneWithoutSkillsInput {
  connect: EgoWhereUniqueInput
  create: EgoCreateWithoutSkillsInput
  delete: Boolean
  disconnect: Boolean
  update: EgoUpdateWithoutSkillsDataInput
  upsert: EgoUpsertWithoutSkillsInput
}

input EgoUpdateWithoutSkillsDataInput {
  cog: Int
  id: ID
  int: Int
  name: String
  ref: Int
  sav: Int
  som: Int
  wil: Int
}

input EgoUpsertWithoutSkillsInput {
  create: EgoCreateWithoutSkillsInput!
  update: EgoUpdateWithoutSkillsDataInput!
}

input EgoWhereInput {
  AND: [EgoWhereInput!]
  cog: IntFilter
  id: StringFilter
  int: IntFilter
  name: StringFilter
  NOT: [EgoWhereInput!]
  OR: [EgoWhereInput!]
  ref: IntFilter
  sav: IntFilter
  skills: SkillFilter
  som: IntFilter
  wil: IntFilter
}

input EgoWhereUniqueInput {
  id: ID
  name: String
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

type Morph {
  avail: Int!
  cost: Int!
  dr: Int!
  dur: Int!
  flex: Int!
  id: ID!
  insight: Int!
  movementRate: String
  moxie: Int!
  notes: String
  traits(after: String, before: String, first: Int, last: Int, skip: Int): [MorphTrait!]!
  type: MorphType!
  vigor: Int!
  ware(after: String, before: String, first: Int, last: Int, skip: Int): [Ware!]!
  wt: Int!
}

input MorphCreateInput {
  avail: Int!
  cost: Int!
  dr: Int!
  dur: Int!
  flex: Int!
  id: ID
  insight: Int!
  movementRate: String
  moxie: Int!
  name: String!
  nonPlayerCharacter: NonPlayerCharacterCreateOneWithoutNonPlayerCharacterInput
  notes: String
  traits: MorphTraitCreateManyWithoutTraitsInput
  type: MorphType!
  vigor: Int!
  ware: WareCreateManyWithoutWareInput
  wt: Int!
}

input MorphCreateManyWithoutMorphsInput {
  connect: [MorphWhereUniqueInput!]
  create: [MorphCreateWithoutWareInput!]
}

input MorphCreateOneWithoutMorphInput {
  connect: MorphWhereUniqueInput
  create: MorphCreateWithoutNonPlayerCharacterInput
}

input MorphCreateWithoutNonPlayerCharacterInput {
  avail: Int!
  cost: Int!
  dr: Int!
  dur: Int!
  flex: Int!
  id: ID
  insight: Int!
  movementRate: String
  moxie: Int!
  name: String!
  notes: String
  traits: MorphTraitCreateManyWithoutTraitsInput
  type: MorphType!
  vigor: Int!
  ware: WareCreateManyWithoutWareInput
  wt: Int!
}

input MorphCreateWithoutWareInput {
  avail: Int!
  cost: Int!
  dr: Int!
  dur: Int!
  flex: Int!
  id: ID
  insight: Int!
  movementRate: String
  moxie: Int!
  name: String!
  nonPlayerCharacter: NonPlayerCharacterCreateOneWithoutNonPlayerCharacterInput
  notes: String
  traits: MorphTraitCreateManyWithoutTraitsInput
  type: MorphType!
  vigor: Int!
  wt: Int!
}

input MorphFilter {
  every: MorphWhereInput
  none: MorphWhereInput
  some: MorphWhereInput
}

input MorphScalarWhereInput {
  AND: [MorphScalarWhereInput!]
  avail: IntFilter
  cost: IntFilter
  dr: IntFilter
  dur: IntFilter
  flex: IntFilter
  id: StringFilter
  insight: IntFilter
  movementRate: NullableStringFilter
  moxie: IntFilter
  name: StringFilter
  NOT: [MorphScalarWhereInput!]
  notes: NullableStringFilter
  OR: [MorphScalarWhereInput!]
  traits: MorphTraitFilter
  type: MorphType
  vigor: IntFilter
  ware: WareFilter
  wt: IntFilter
}

type MorphTrait {
  id: ID!
  name: String!
}

input MorphTraitCreateManyWithoutTraitsInput {
  connect: [MorphTraitWhereUniqueInput!]
  create: [MorphTraitCreateWithoutMorphsInput!]
}

input MorphTraitCreateWithoutMorphsInput {
  id: ID
  name: String!
}

input MorphTraitFilter {
  every: MorphTraitWhereInput
  none: MorphTraitWhereInput
  some: MorphTraitWhereInput
}

input MorphTraitScalarWhereInput {
  AND: [MorphTraitScalarWhereInput!]
  id: StringFilter
  morphs: MorphFilter
  name: StringFilter
  NOT: [MorphTraitScalarWhereInput!]
  OR: [MorphTraitScalarWhereInput!]
}

input MorphTraitUpdateManyDataInput {
  id: ID
  name: String
}

input MorphTraitUpdateManyWithoutMorphsInput {
  connect: [MorphTraitWhereUniqueInput!]
  create: [MorphTraitCreateWithoutMorphsInput!]
  delete: [MorphTraitWhereUniqueInput!]
  deleteMany: [MorphTraitScalarWhereInput!]
  disconnect: [MorphTraitWhereUniqueInput!]
  set: [MorphTraitWhereUniqueInput!]
  update: [MorphTraitUpdateWithWhereUniqueWithoutMorphsInput!]
  updateMany: [MorphTraitUpdateManyWithWhereNestedInput!]
  upsert: [MorphTraitUpsertWithWhereUniqueWithoutMorphsInput!]
}

input MorphTraitUpdateManyWithWhereNestedInput {
  data: MorphTraitUpdateManyDataInput!
  where: MorphTraitScalarWhereInput!
}

input MorphTraitUpdateWithoutMorphsDataInput {
  id: ID
  name: String
}

input MorphTraitUpdateWithWhereUniqueWithoutMorphsInput {
  data: MorphTraitUpdateWithoutMorphsDataInput!
  where: MorphTraitWhereUniqueInput!
}

input MorphTraitUpsertWithWhereUniqueWithoutMorphsInput {
  create: MorphTraitCreateWithoutMorphsInput!
  update: MorphTraitUpdateWithoutMorphsDataInput!
  where: MorphTraitWhereUniqueInput!
}

input MorphTraitWhereInput {
  AND: [MorphTraitWhereInput!]
  id: StringFilter
  morphs: MorphFilter
  name: StringFilter
  NOT: [MorphTraitWhereInput!]
  OR: [MorphTraitWhereInput!]
}

input MorphTraitWhereUniqueInput {
  id: ID
  name: String
}

enum MorphType {
  Biomorph
  Infomorph
  Synthmorph
}

input MorphUpdateInput {
  avail: Int
  cost: Int
  dr: Int
  dur: Int
  flex: Int
  id: ID
  insight: Int
  movementRate: String
  moxie: Int
  name: String
  nonPlayerCharacter: NonPlayerCharacterUpdateOneWithoutMorphInput
  notes: String
  traits: MorphTraitUpdateManyWithoutMorphsInput
  type: MorphType
  vigor: Int
  ware: WareUpdateManyWithoutMorphsInput
  wt: Int
}

input MorphUpdateManyDataInput {
  avail: Int
  cost: Int
  dr: Int
  dur: Int
  flex: Int
  id: ID
  insight: Int
  movementRate: String
  moxie: Int
  name: String
  notes: String
  type: MorphType
  vigor: Int
  wt: Int
}

input MorphUpdateManyWithoutWareInput {
  connect: [MorphWhereUniqueInput!]
  create: [MorphCreateWithoutWareInput!]
  delete: [MorphWhereUniqueInput!]
  deleteMany: [MorphScalarWhereInput!]
  disconnect: [MorphWhereUniqueInput!]
  set: [MorphWhereUniqueInput!]
  update: [MorphUpdateWithWhereUniqueWithoutWareInput!]
  updateMany: [MorphUpdateManyWithWhereNestedInput!]
  upsert: [MorphUpsertWithWhereUniqueWithoutWareInput!]
}

input MorphUpdateManyWithWhereNestedInput {
  data: MorphUpdateManyDataInput!
  where: MorphScalarWhereInput!
}

input MorphUpdateOneRequiredWithoutNonPlayerCharacterInput {
  connect: MorphWhereUniqueInput
  create: MorphCreateWithoutNonPlayerCharacterInput
  update: MorphUpdateWithoutNonPlayerCharacterDataInput
  upsert: MorphUpsertWithoutNonPlayerCharacterInput
}

input MorphUpdateWithoutNonPlayerCharacterDataInput {
  avail: Int
  cost: Int
  dr: Int
  dur: Int
  flex: Int
  id: ID
  insight: Int
  movementRate: String
  moxie: Int
  name: String
  notes: String
  traits: MorphTraitUpdateManyWithoutMorphsInput
  type: MorphType
  vigor: Int
  ware: WareUpdateManyWithoutMorphsInput
  wt: Int
}

input MorphUpdateWithoutWareDataInput {
  avail: Int
  cost: Int
  dr: Int
  dur: Int
  flex: Int
  id: ID
  insight: Int
  movementRate: String
  moxie: Int
  name: String
  nonPlayerCharacter: NonPlayerCharacterUpdateOneWithoutMorphInput
  notes: String
  traits: MorphTraitUpdateManyWithoutMorphsInput
  type: MorphType
  vigor: Int
  wt: Int
}

input MorphUpdateWithWhereUniqueWithoutWareInput {
  data: MorphUpdateWithoutWareDataInput!
  where: MorphWhereUniqueInput!
}

input MorphUpsertWithoutNonPlayerCharacterInput {
  create: MorphCreateWithoutNonPlayerCharacterInput!
  update: MorphUpdateWithoutNonPlayerCharacterDataInput!
}

input MorphUpsertWithWhereUniqueWithoutWareInput {
  create: MorphCreateWithoutWareInput!
  update: MorphUpdateWithoutWareDataInput!
  where: MorphWhereUniqueInput!
}

input MorphWhereInput {
  AND: [MorphWhereInput!]
  avail: IntFilter
  cost: IntFilter
  dr: IntFilter
  dur: IntFilter
  flex: IntFilter
  id: StringFilter
  insight: IntFilter
  movementRate: NullableStringFilter
  moxie: IntFilter
  name: StringFilter
  nonPlayerCharacter: NonPlayerCharacterWhereInput
  NOT: [MorphWhereInput!]
  notes: NullableStringFilter
  OR: [MorphWhereInput!]
  traits: MorphTraitFilter
  type: MorphType
  vigor: IntFilter
  ware: WareFilter
  wt: IntFilter
}

input MorphWhereUniqueInput {
  id: ID
  name: String
}

type Mutation {
  createOneEgo(data: EgoCreateInput!): Ego!
  createOneMorph(data: MorphCreateInput!): Morph!
  createOneNonPlayerCharacter(data: NonPlayerCharacterCreateInput!): NonPlayerCharacter!
  createOneSkill(data: SkillCreateInput!): Skill!
  createOneWare(data: WareCreateInput!): Ware!
  deleteOneEgo(where: EgoWhereUniqueInput!): Ego
  deleteOneMorph(where: MorphWhereUniqueInput!): Morph
  deleteOneNonPlayerCharacter(where: NonPlayerCharacterWhereUniqueInput!): NonPlayerCharacter
  deleteOneSkill(where: SkillWhereUniqueInput!): Skill
  deleteOneWare(where: WareWhereUniqueInput!): Ware
  updateOneEgo(data: EgoUpdateInput!, where: EgoWhereUniqueInput!): Ego
  updateOneMorph(data: MorphUpdateInput!, where: MorphWhereUniqueInput!): Morph
  updateOneNonPlayerCharacter(data: NonPlayerCharacterUpdateInput!, where: NonPlayerCharacterWhereUniqueInput!): NonPlayerCharacter
  updateOneSkill(data: SkillUpdateInput!, where: SkillWhereUniqueInput!): Skill
  updateOneWare(data: WareUpdateInput!, where: WareWhereUniqueInput!): Ware
  upsertOneEgo(create: EgoCreateInput!, update: EgoUpdateInput!, where: EgoWhereUniqueInput!): Ego!
  upsertOneMorph(create: MorphCreateInput!, update: MorphUpdateInput!, where: MorphWhereUniqueInput!): Morph!
  upsertOneNonPlayerCharacter(create: NonPlayerCharacterCreateInput!, update: NonPlayerCharacterUpdateInput!, where: NonPlayerCharacterWhereUniqueInput!): NonPlayerCharacter!
  upsertOneSkill(create: SkillCreateInput!, update: SkillUpdateInput!, where: SkillWhereUniqueInput!): Skill!
  upsertOneWare(create: WareCreateInput!, update: WareUpdateInput!, where: WareWhereUniqueInput!): Ware!
}

type NonPlayerCharacter {
  cog: Int!
  createdAt: DateTime!
  id: ID!
  int: Int!
  ref: Int!
  sav: Int!
  skills(after: String, before: String, first: Int, last: Int, skip: Int): [Skill!]!
  som: Int!
  threatPool: Int!
  updatedAt: DateTime!
  wil: Int!
}

input NonPlayerCharacterCreateInput {
  cog: Int!
  createdAt: DateTime
  id: ID
  int: Int!
  morph: MorphCreateOneWithoutMorphInput!
  ref: Int!
  sav: Int!
  skills: SkillCreateManyWithoutSkillsInput
  som: Int!
  threatPool: Int!
  updatedAt: DateTime
  wil: Int!
}

input NonPlayerCharacterCreateOneWithoutNonPlayerCharacterInput {
  connect: NonPlayerCharacterWhereUniqueInput
  create: NonPlayerCharacterCreateWithoutSkillsInput
}

input NonPlayerCharacterCreateWithoutMorphInput {
  cog: Int!
  createdAt: DateTime
  id: ID
  int: Int!
  ref: Int!
  sav: Int!
  skills: SkillCreateManyWithoutSkillsInput
  som: Int!
  threatPool: Int!
  updatedAt: DateTime
  wil: Int!
}

input NonPlayerCharacterCreateWithoutSkillsInput {
  cog: Int!
  createdAt: DateTime
  id: ID
  int: Int!
  morph: MorphCreateOneWithoutMorphInput!
  ref: Int!
  sav: Int!
  som: Int!
  threatPool: Int!
  updatedAt: DateTime
  wil: Int!
}

input NonPlayerCharacterUpdateInput {
  cog: Int
  createdAt: DateTime
  id: ID
  int: Int
  morph: MorphUpdateOneRequiredWithoutNonPlayerCharacterInput
  ref: Int
  sav: Int
  skills: SkillUpdateManyWithoutNonPlayerCharacterInput
  som: Int
  threatPool: Int
  updatedAt: DateTime
  wil: Int
}

input NonPlayerCharacterUpdateOneWithoutMorphInput {
  connect: NonPlayerCharacterWhereUniqueInput
  create: NonPlayerCharacterCreateWithoutMorphInput
  delete: Boolean
  disconnect: Boolean
  update: NonPlayerCharacterUpdateWithoutMorphDataInput
  upsert: NonPlayerCharacterUpsertWithoutMorphInput
}

input NonPlayerCharacterUpdateOneWithoutSkillsInput {
  connect: NonPlayerCharacterWhereUniqueInput
  create: NonPlayerCharacterCreateWithoutSkillsInput
  delete: Boolean
  disconnect: Boolean
  update: NonPlayerCharacterUpdateWithoutSkillsDataInput
  upsert: NonPlayerCharacterUpsertWithoutSkillsInput
}

input NonPlayerCharacterUpdateWithoutMorphDataInput {
  cog: Int
  createdAt: DateTime
  id: ID
  int: Int
  ref: Int
  sav: Int
  skills: SkillUpdateManyWithoutNonPlayerCharacterInput
  som: Int
  threatPool: Int
  updatedAt: DateTime
  wil: Int
}

input NonPlayerCharacterUpdateWithoutSkillsDataInput {
  cog: Int
  createdAt: DateTime
  id: ID
  int: Int
  morph: MorphUpdateOneRequiredWithoutNonPlayerCharacterInput
  ref: Int
  sav: Int
  som: Int
  threatPool: Int
  updatedAt: DateTime
  wil: Int
}

input NonPlayerCharacterUpsertWithoutMorphInput {
  create: NonPlayerCharacterCreateWithoutMorphInput!
  update: NonPlayerCharacterUpdateWithoutMorphDataInput!
}

input NonPlayerCharacterUpsertWithoutSkillsInput {
  create: NonPlayerCharacterCreateWithoutSkillsInput!
  update: NonPlayerCharacterUpdateWithoutSkillsDataInput!
}

input NonPlayerCharacterWhereInput {
  AND: [NonPlayerCharacterWhereInput!]
  cog: IntFilter
  createdAt: DateTimeFilter
  id: StringFilter
  int: IntFilter
  morph: MorphWhereInput
  NOT: [NonPlayerCharacterWhereInput!]
  OR: [NonPlayerCharacterWhereInput!]
  ref: IntFilter
  sav: IntFilter
  skills: SkillFilter
  som: IntFilter
  threatPool: IntFilter
  updatedAt: DateTimeFilter
  wil: IntFilter
}

input NonPlayerCharacterWhereUniqueInput {
  id: ID
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Query {
  ego(where: EgoWhereUniqueInput!): Ego
  egos(after: String, before: String, first: Int, last: Int, skip: Int): [Ego!]!
  morph(where: MorphWhereUniqueInput!): Morph
  morphs(after: String, before: String, first: Int, last: Int, skip: Int): [Morph!]!
  nonplayercharacter(where: NonPlayerCharacterWhereUniqueInput!): NonPlayerCharacter
  nonplayercharacters(after: String, before: String, first: Int, last: Int, skip: Int): [NonPlayerCharacter!]!
  skill(where: SkillWhereUniqueInput!): Skill
  skills(after: String, before: String, first: Int, last: Int, skip: Int): [Skill!]!
  ware(where: WareWhereUniqueInput!): Ware
  wares(after: String, before: String, first: Int, last: Int, skip: Int): [Ware!]!
}

type Skill {
  id: ID!
  linkedAptitude: Aptitude!
  name: String!
}

input SkillCreateInput {
  ego: EgoCreateOneWithoutEgoInput
  id: ID
  linkedAptitude: Aptitude!
  name: String!
  nonPlayerCharacter: NonPlayerCharacterCreateOneWithoutNonPlayerCharacterInput
}

input SkillCreateManyWithoutSkillsInput {
  connect: [SkillWhereUniqueInput!]
  create: [SkillCreateWithoutEgoInput!]
}

input SkillCreateWithoutEgoInput {
  id: ID
  linkedAptitude: Aptitude!
  name: String!
  nonPlayerCharacter: NonPlayerCharacterCreateOneWithoutNonPlayerCharacterInput
}

input SkillCreateWithoutNonPlayerCharacterInput {
  ego: EgoCreateOneWithoutEgoInput
  id: ID
  linkedAptitude: Aptitude!
  name: String!
}

input SkillFilter {
  every: SkillWhereInput
  none: SkillWhereInput
  some: SkillWhereInput
}

input SkillScalarWhereInput {
  AND: [SkillScalarWhereInput!]
  id: StringFilter
  linkedAptitude: Aptitude
  name: StringFilter
  NOT: [SkillScalarWhereInput!]
  OR: [SkillScalarWhereInput!]
}

input SkillUpdateInput {
  ego: EgoUpdateOneWithoutSkillsInput
  id: ID
  linkedAptitude: Aptitude
  name: String
  nonPlayerCharacter: NonPlayerCharacterUpdateOneWithoutSkillsInput
}

input SkillUpdateManyDataInput {
  id: ID
  linkedAptitude: Aptitude
  name: String
}

input SkillUpdateManyWithoutEgoInput {
  connect: [SkillWhereUniqueInput!]
  create: [SkillCreateWithoutEgoInput!]
  delete: [SkillWhereUniqueInput!]
  deleteMany: [SkillScalarWhereInput!]
  disconnect: [SkillWhereUniqueInput!]
  set: [SkillWhereUniqueInput!]
  update: [SkillUpdateWithWhereUniqueWithoutEgoInput!]
  updateMany: [SkillUpdateManyWithWhereNestedInput!]
  upsert: [SkillUpsertWithWhereUniqueWithoutEgoInput!]
}

input SkillUpdateManyWithoutNonPlayerCharacterInput {
  connect: [SkillWhereUniqueInput!]
  create: [SkillCreateWithoutNonPlayerCharacterInput!]
  delete: [SkillWhereUniqueInput!]
  deleteMany: [SkillScalarWhereInput!]
  disconnect: [SkillWhereUniqueInput!]
  set: [SkillWhereUniqueInput!]
  update: [SkillUpdateWithWhereUniqueWithoutNonPlayerCharacterInput!]
  updateMany: [SkillUpdateManyWithWhereNestedInput!]
  upsert: [SkillUpsertWithWhereUniqueWithoutNonPlayerCharacterInput!]
}

input SkillUpdateManyWithWhereNestedInput {
  data: SkillUpdateManyDataInput!
  where: SkillScalarWhereInput!
}

input SkillUpdateWithoutEgoDataInput {
  id: ID
  linkedAptitude: Aptitude
  name: String
  nonPlayerCharacter: NonPlayerCharacterUpdateOneWithoutSkillsInput
}

input SkillUpdateWithoutNonPlayerCharacterDataInput {
  ego: EgoUpdateOneWithoutSkillsInput
  id: ID
  linkedAptitude: Aptitude
  name: String
}

input SkillUpdateWithWhereUniqueWithoutEgoInput {
  data: SkillUpdateWithoutEgoDataInput!
  where: SkillWhereUniqueInput!
}

input SkillUpdateWithWhereUniqueWithoutNonPlayerCharacterInput {
  data: SkillUpdateWithoutNonPlayerCharacterDataInput!
  where: SkillWhereUniqueInput!
}

input SkillUpsertWithWhereUniqueWithoutEgoInput {
  create: SkillCreateWithoutEgoInput!
  update: SkillUpdateWithoutEgoDataInput!
  where: SkillWhereUniqueInput!
}

input SkillUpsertWithWhereUniqueWithoutNonPlayerCharacterInput {
  create: SkillCreateWithoutNonPlayerCharacterInput!
  update: SkillUpdateWithoutNonPlayerCharacterDataInput!
  where: SkillWhereUniqueInput!
}

input SkillWhereInput {
  AND: [SkillWhereInput!]
  ego: EgoWhereInput
  id: StringFilter
  linkedAptitude: Aptitude
  name: StringFilter
  nonPlayerCharacter: NonPlayerCharacterWhereInput
  NOT: [SkillWhereInput!]
  OR: [SkillWhereInput!]
}

input SkillWhereUniqueInput {
  id: ID
  name: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Ware {
  id: ID!
  name: String!
}

input WareCreateInput {
  id: ID
  morphs: MorphCreateManyWithoutMorphsInput
  name: String!
}

input WareCreateManyWithoutWareInput {
  connect: [WareWhereUniqueInput!]
  create: [WareCreateWithoutMorphsInput!]
}

input WareCreateWithoutMorphsInput {
  id: ID
  name: String!
}

input WareFilter {
  every: WareWhereInput
  none: WareWhereInput
  some: WareWhereInput
}

input WareScalarWhereInput {
  AND: [WareScalarWhereInput!]
  id: StringFilter
  morphs: MorphFilter
  name: StringFilter
  NOT: [WareScalarWhereInput!]
  OR: [WareScalarWhereInput!]
}

input WareUpdateInput {
  id: ID
  morphs: MorphUpdateManyWithoutWareInput
  name: String
}

input WareUpdateManyDataInput {
  id: ID
  name: String
}

input WareUpdateManyWithoutMorphsInput {
  connect: [WareWhereUniqueInput!]
  create: [WareCreateWithoutMorphsInput!]
  delete: [WareWhereUniqueInput!]
  deleteMany: [WareScalarWhereInput!]
  disconnect: [WareWhereUniqueInput!]
  set: [WareWhereUniqueInput!]
  update: [WareUpdateWithWhereUniqueWithoutMorphsInput!]
  updateMany: [WareUpdateManyWithWhereNestedInput!]
  upsert: [WareUpsertWithWhereUniqueWithoutMorphsInput!]
}

input WareUpdateManyWithWhereNestedInput {
  data: WareUpdateManyDataInput!
  where: WareScalarWhereInput!
}

input WareUpdateWithoutMorphsDataInput {
  id: ID
  name: String
}

input WareUpdateWithWhereUniqueWithoutMorphsInput {
  data: WareUpdateWithoutMorphsDataInput!
  where: WareWhereUniqueInput!
}

input WareUpsertWithWhereUniqueWithoutMorphsInput {
  create: WareCreateWithoutMorphsInput!
  update: WareUpdateWithoutMorphsDataInput!
  where: WareWhereUniqueInput!
}

input WareWhereInput {
  AND: [WareWhereInput!]
  id: StringFilter
  morphs: MorphFilter
  name: StringFilter
  NOT: [WareWhereInput!]
  OR: [WareWhereInput!]
}

input WareWhereUniqueInput {
  id: ID
  name: String
}
